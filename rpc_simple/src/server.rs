use futures::{
    future::{self, Ready},
    prelude::*,
};
use service::World;
use std::{
    io,
    net::{IpAddr, SocketAddr},
};
use tarpc::{
    context,
    server::{self, Channel, Handler},
};
use tokio_serde::formats::Json;


#[derive(Clone)]
pub struct HelloServer(SocketAddr);

impl World for HelloServer {
    // Each defined rpc generates two items in the trait, a fn that serves the RPC, and
    // an associated type representing the future output by the fn.

    type HelloFut = Ready<String>;

    fn hello(self, _: context::Context, name: String) -> Self::HelloFut {
        future::ready(format!(
            "Hello, {}! You are connected from {:?}.",
            name, self.0
        ))
    }
}


#[tokio::main]
async fn main() -> io::Result<()> {
    let mut ths = vec![];

    for port in 8000..8008 {
        let server_addr = format!("127.0.0.1:{}", port);
        let server_addr = server_addr.parse::<SocketAddr>().unwrap();
        let th = tokio::spawn(async move {
            tarpc::serde_transport::tcp::listen(&server_addr, Json::default)
                .await
                .unwrap()
                // Ignore accept errors.
                .filter_map(|r| future::ready(r.ok()))
                .map(server::BaseChannel::with_defaults)
                // Limit channels to 1 per IP.
                .max_channels_per_key(1, |t| t.as_ref().peer_addr().unwrap().ip())
                // serve is generated by the service attribute. It takes as input any type implementing
                // the generated World trait.
                .map(|channel| {
                    let server = HelloServer(channel.as_ref().as_ref().peer_addr().unwrap());
                    channel.respond_with(server.serve()).execute()
                })
            .buffer_unordered(10)
                .for_each(|_| async {
                    println!("Got collection.");
                })
            .await;

            });
        ths.push(th);
    }

    for th in ths.into_iter() {
        th.await?;
    }

    Ok(())
}
